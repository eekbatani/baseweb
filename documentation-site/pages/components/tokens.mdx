<!--
Copyright (c) 2018-2019 Uber Technologies, Inc.

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.
-->

import Example from '../../components/example';
import Layout from '../../components/layout';
import BasicExample from 'examples/tokens/basic.js';
import Exports from '../../components/exports';
import {H3, Paragraph} from '../../components/markdown-elements.js';
import {
  colors,
  darkThemeSemanticColors,
  lightThemeSemanticColors,
} from 'baseui/tokens';
import {ThemeConsumer} from 'baseui';

export default Layout;

export const colorToNameMap = {};
export function ColorPreviewContainer(props) {
  return (
    <div
      style={{
        fontFamily: 'Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace',
        fontSize: '14px',
        lineHeight: 1,
      }}
      {...props}
    />
  );
}
export function ColorPreview({name, value, displayValue}) {
  return (
    <div
      style={{
        display: 'flex',
        alignItems: 'center',
        borderBottom: `solid 1px ${value}`,
      }}
    >
      <div
        style={{
          backgroundColor: value,
          width: '100px',
          minWidth: '100px',
          height: '50px',
          marginRight: '20px',
        }}
      ></div>
      <div style={{flexGrow: 1}}>{name}</div>
      <div>{displayValue}</div>
    </div>
  );
}

# Tokens

You can import Base Web design tokens from `baseui/tokens`. Tokens can be primitive or semantic.

A primitive token is just an alias for a value in your design system, such as a hex or pixel value.
It creates a consistent way to reference an immutable value in a design system. For example:

```js
const acmeBlue = '#0000FF';
```

A semantic token intended to be used according to its semantic meaning and allows theming applications in a different way.
It alises a primitive token and it's value can be changed per theme. For example:

```js
const backgroundAccent = acmeBlue;
```

Anytime someone needs to reference the accent fill color for Acme Co. there is a single place it is defined and exported.

Currently we only export primitive color tokens (`colors`) and semantic color tokens (`lightThemeSemanticColors` and `darkThemeSemanticColors`) from `baseui/tokens`.
In the future, we may add more types of values to the module such as typography and spacing values.

## Usage

So what do you do with a color token? Should you import it wherever you need to use the color? Should you alias it in your theme object?

You could employ either of those strategies for semantic color tokens usage.
See an example of extending a theme with semantic color tokens below.

```js
// myTheme.js

import {LightTheme} from 'baseui';
import {lightThemeSemanticColors} from 'baseui/tokens';
import extend from 'just-extend';

const myTheme = extend(
  {extendedSemanticColors: lightThemeSemanticColors},
  LightTheme,
);

export default myTheme;
```

You can also extend a custom theme with semantic color tokens while creating the theme. For example:

```js
// myTheme.js

import {createTheme, lightThemePrimitives} from 'baseui';
import {colors, lightThemeSemanticColors} from 'baseui/tokens';

const myThemePrimitives = {
  ...lightThemePrimitives,
  primary: colors.blue400,
  primary50: colors.blue50,
  primary100: colors.blue100,
  primary200: colors.blue200,
  primary300: colors.blue300,
  primary400: colors.blue400,
  primary500: colors.blue500,
  primary600: colors.blue600,
  primary700: colors.blue700,
};

const myTheme = createTheme(myThemePrimitives, {
  extendedSemanticColors: lightThemeSemanticColors,
});

export default myTheme;
```

Use sparingly primitive color tokens directly. The best way to use primitive color tokens
with `baseui` is to assign them to your theme's building primitives. Here is what that might look like:

```js
// myTheme.js

import {createTheme, lightThemePrimitives} from 'baseui';
import {colors} from 'baseui/tokens';

const myThemePrimitives = {
  ...lightThemePrimitives,
  primary: colors.blue400,
  primary50: colors.blue50,
  primary100: colors.blue100,
  primary200: colors.blue200,
  primary300: colors.blue300,
  primary400: colors.blue400,
  primary500: colors.blue500,
  primary600: colors.blue600,
  primary700: colors.blue700,
};

const myTheme = createTheme(myThemePrimitives);

export default myTheme;
```

You could also assign primitive color tokens as overrides on the theme if there is a specific theme property that needs further customization.
Sometimes our default mapping of theme's building primitives to theme properties may differ from your own intentions.

```js
// myTheme.js

import {createTheme, lightThemePrimitives} from 'baseui';
import {colors} from 'baseui/tokens';

const myThemeOverrides = {
  colors: {
    borderFocus: colors.yellow200,
  },
};

const myTheme = createTheme(lightThemePrimitives, myThemeOverrides);

export default myTheme;
```

It is best to assign things at the theme's building primitives level, with overrides as a backup.
When you assign tokens directly in component code or alias them on the theme object you
are opting out of the `baseui` way of doing things. We will try to support those use
cases the best we can, but our priority will always be supporting theme primitives and
overrides first.

For more on `baseui` theming check out [the documentation](/guides/theming).

## Primitive Color Tokens

<ColorPreviewContainer>
  {Object.entries(colors).map(([name, value]) => {
    colorToNameMap[value] = name;
    return <ColorPreview name={name} value={value} displayValue={value} />;
  })}
</ColorPreviewContainer>

Not every color listed here is used in a `baseui` component. This is simply the complete set of official Base Web colors. Ideally these are the only colors you would need to use in a Base Web project.

## Semantic Color Tokens

<ThemeConsumer>
  {theme => {
    const tokens = theme.name.startsWith('dark')
      ? darkThemeSemanticColors
      : lightThemeSemanticColors;
    const semanticTokensGrouped = {
      foundation: [],
      background: [],
      content: [],
      border: [],
    };
    Object.entries(tokens).forEach(([name, value]) => {
      const colorPreview = (
        <ColorPreview
          name={name}
          value={value}
          displayValue={`${
            colorToNameMap[value] ? `${colorToNameMap[value]} / ` : ''
          }${value}`}
        />
      );
      if (name.startsWith('background')) {
        semanticTokensGrouped.background.push(colorPreview);
      } else if (name.startsWith('content')) {
        semanticTokensGrouped.content.push(colorPreview);
      } else if (name.startsWith('border')) {
        semanticTokensGrouped.border.push(colorPreview);
      } else {
        semanticTokensGrouped.foundation.push(colorPreview);
      }
    });
    return (
      <ColorPreviewContainer>
        <H3>Foundation</H3>
        <Paragraph>
          Represent foundational colors for the rest of the theme. These tokens
          shouldn't be used directly except when globally changing your
          application's accent color.
        </Paragraph>
        {semanticTokensGrouped.foundation}
        <H3>Background</H3>
        <Paragraph>
          Any background container. No icons, no text. Background can be the
          fill of a list view, the backer behind a map control, the page
          background, etc.
        </Paragraph>
        {semanticTokensGrouped.background}
        <H3>Content</H3>
        <Paragraph>
          Content is any text or icon element. It can be the fill of an arrow,
          or the color of a paragraph, or the color of label inside a button,
          etc.
        </Paragraph>
        {semanticTokensGrouped.content}
        <H3>Border</H3>
        <Paragraph>
          Border All line elements get a border token. This can be a dashed line
          in a receipt, or a selected outline around an input field, or a list
          view divider, etc.
        </Paragraph>
        {semanticTokensGrouped.border}
      </ColorPreviewContainer>
    );
  }}
</ThemeConsumer>
